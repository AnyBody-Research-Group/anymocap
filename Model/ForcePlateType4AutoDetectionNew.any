#class_template ForcePlateType4AutoDetection (
    No,
    C3D_OBJECT = Main.ModelSetup.C3DFileData,
    LIMB1 = Main.HumanModel.BodyModel.Right.Leg.Seg.Foot,
    LIMB2 = Main.HumanModel.BodyModel.Left.Leg.Seg.Foot,
    VerticalDirection = "Automatic",
    HeightTolerance = 0.07,
    VelThreshold = 2.2, 
    FootPresent=1,
	FORCEPLATE_TYPE = 4,
	CREATE_KIN_GRF = 0)
{
      
  AnyRefFrame &Limb1 = LIMB1;
  AnyRefFrame &Limb2 = LIMB2;
  
  
  // These can be overridden to specify a special channel to read the data from
  // Must be given as a pointer to the data 
  // Fx = &Main.ModelSetup.C3DFileData.Analog.Data.Fx;
  
  #var AnyObjectPtrVar Fx = AutoLocateChannels.Fx;
  #var AnyObjectPtrVar Fy = AutoLocateChannels.Fy;
  #var AnyObjectPtrVar Fz = AutoLocateChannels.Fz;
  #var AnyObjectPtrVar Mx = AutoLocateChannels.Mx;
  #var AnyObjectPtrVar My = AutoLocateChannels.My;
  #var AnyObjectPtrVar Mz = AutoLocateChannels.Mz;
  
  /// Contains the logic to find the correct analog channels from the C3D file   
  AnyFolder AutoLocateChannels = {
    AnyInt ChIdxs = C3D_OBJECT.Groups.FORCE_PLATFORM.CHANNEL.Data[No]-1;
    /// Hack to ensure that the pointers get a later evalution moment.
    AnyString dot = DesignVar(".");
    AnyObjectPtrVar Fx = ObjSearch(CompleteNameOf(&C3D_OBJECT.Analog.DataFiltered)+ dot + C3D_OBJECT.AnalogLabels[ChIdxs[0]])[0];
    AnyObjectPtrVar Fy = ObjSearch(CompleteNameOf(&C3D_OBJECT.Analog.DataFiltered)+ dot + C3D_OBJECT.AnalogLabels[ChIdxs[1]])[0];
    AnyObjectPtrVar Fz = ObjSearch(CompleteNameOf(&C3D_OBJECT.Analog.DataFiltered)+ dot + C3D_OBJECT.AnalogLabels[ChIdxs[2]])[0];
    AnyObjectPtrVar Mx = ObjSearch(CompleteNameOf(&C3D_OBJECT.Analog.DataFiltered)+ dot + C3D_OBJECT.AnalogLabels[ChIdxs[3]])[0];
    AnyObjectPtrVar My = ObjSearch(CompleteNameOf(&C3D_OBJECT.Analog.DataFiltered)+ dot + C3D_OBJECT.AnalogLabels[ChIdxs[4]])[0];
    AnyObjectPtrVar Mz = ObjSearch(CompleteNameOf(&C3D_OBJECT.Analog.DataFiltered)+ dot + C3D_OBJECT.AnalogLabels[ChIdxs[5]])[0];    
  };
  
  #var AnyFloat Cal = C3D_OBJECT.Groups.FORCE_PLATFORM.CAL_MATRIX.Data[No];  
  #var AnySwitch Switch_DrawForceVectorFromCOP = On;
  #var AnyVar MaxLoad = max( vnorm({Obj2Num(Fx),Obj2Num(Fy),Obj2Num(Fz)}') );

  #var AnyVec3 SurfaceOffset = {0,0,0};
  
  #var AnyVec3 SurfaceCorner_c01 = Corners.Origin + Corners.c01.sRel * Corners.Axes' + SurfaceOffset;
  #var AnyVec3 SurfaceCorner_c02 = Corners.Origin + Corners.c02.sRel * Corners.Axes' + SurfaceOffset;
  #var AnyVec3 SurfaceCorner_c03 = Corners.Origin + Corners.c03.sRel * Corners.Axes' + SurfaceOffset;
  #var AnyVec3 SurfaceCorner_c04 = Corners.Origin + Corners.c04.sRel * Corners.Axes' + SurfaceOffset;
  
    
  AnyMessage Assertion  = {
      AnyInt test = neqfun(C3D_OBJECT.Groups.FORCE_PLATFORM.TYPE.Data[No], FORCEPLATE_TYPE);
      TriggerConst = test;
      Type = MSG_ErrorFatal ;
      Message = strformat("AnyMOCAP: Wrong force plate type:\n"+
	            "C3D file reports force plate as beeing type " +
				strval(C3D_OBJECT.Groups.FORCE_PLATFORM.TYPE.Data[No]) + 
				" not type: " + strval(FORCEPLATE_TYPE));
   };  
  
  
  AnyFixedRefFrame Corners ={
    AnyVar CoordinateSystemSize= 0.1;
    
    AnyRefNode c01={
      AnyInt i=0;
      AnyInt plnr=No;
      sRel=C3D_OBJECT.PointsScaleFactor*{
          C3D_OBJECT.Groups.FORCE_PLATFORM.CORNERS.Data[plnr][i][0],
          C3D_OBJECT.Groups.FORCE_PLATFORM.CORNERS.Data[plnr][i][1],
          C3D_OBJECT.Groups.FORCE_PLATFORM.CORNERS.Data[plnr][i][2]
      };
      AnyDrawNode drw={ScaleXYZ=0.01*{1,1,1};RGB={1,0,0};};
      AnyDrawVector  DrawName = {
        Vec = {0.0,0,0};  //use zero length
        Line.Thickness = 0.025; //arbitary value
        Text = "1"; //make reference to name
        Line.RGB={1,0,0};//make reference to color
      };
    };
    
    AnyRefNode c02={
      AnyInt i=1;
      AnyInt plnr=No;
      sRel=C3D_OBJECT.PointsScaleFactor*{
          C3D_OBJECT.Groups.FORCE_PLATFORM.CORNERS.Data[plnr][i][0],
          C3D_OBJECT.Groups.FORCE_PLATFORM.CORNERS.Data[plnr][i][1],
          C3D_OBJECT.Groups.FORCE_PLATFORM.CORNERS.Data[plnr][i][2]
      };
      AnyDrawNode drw={ScaleXYZ=0.01*{1,1,1};RGB={1,0,0};};
      AnyDrawVector  DrawName = {
        Vec = {0.0,0,0};  //use zero length
        Line.Thickness = 0.025; //arbitary value
        Text = "2"; //make reference to name
        Line.RGB={1,0,0};//make reference to color
      };
    };
    
    AnyRefNode c03={
      AnyInt i=2;
      AnyInt plnr=No;
      sRel=C3D_OBJECT.PointsScaleFactor*{
          C3D_OBJECT.Groups.FORCE_PLATFORM.CORNERS.Data[plnr][i][0],
          C3D_OBJECT.Groups.FORCE_PLATFORM.CORNERS.Data[plnr][i][1],
          C3D_OBJECT.Groups.FORCE_PLATFORM.CORNERS.Data[plnr][i][2]
      };
      AnyDrawNode drw={ScaleXYZ=0.01*{1,1,1};RGB={1,0,0};};
      
      AnyDrawVector  DrawName = {
        Vec = {0.0,0,0};  //use zero length
        Line.Thickness = 0.025; //arbitary value
        Text = "3"; //make reference to name
        Line.RGB={1,0,0};//make reference to color
      };
    };
    
    AnyRefNode c04={
      AnyInt i=3;
      AnyInt plnr=No;
      sRel=C3D_OBJECT.PointsScaleFactor*{
          C3D_OBJECT.Groups.FORCE_PLATFORM.CORNERS.Data[plnr][i][0],
          C3D_OBJECT.Groups.FORCE_PLATFORM.CORNERS.Data[plnr][i][1],
          C3D_OBJECT.Groups.FORCE_PLATFORM.CORNERS.Data[plnr][i][2]
      };
      AnyDrawNode drw={ScaleXYZ=0.01*{1,1,1};RGB={1,0,0};};
      AnyDrawVector  DrawName = {
        Vec = {0.0,0,0};  //use zero length
        Line.Thickness = 0.025; //arbitary value
        Text = "4"; //make reference to name
        Line.RGB={1,0,0};//make reference to color
      };
    };
    
    AnyRefNode PlateCenter={
      sRel=0.25*(.c01.sRel+.c02.sRel+.c03.sRel+.c04.sRel);
      AnyVec3 p1=sRel;
      AnyVec3 p2=0.5*(.c01.sRel+.c04.sRel);
      AnyVec3 p3=0.5*(.c01.sRel+.c02.sRel);
      ARel =RotMat(p1,p2,p3);
      //      AnyDrawRefFrame drw={ScaleXYZ=..CoordinateSystemSize*{1,1,1};RGB={0,1,0};};
    };
  };
  
  
  AnySeg ForcePlate={
    Mass=0.0;
    Jii={0,0,0};
    r0=.Corners.PlateCenter.sRel;
    
    //Rotational tranformation matrix for a coordinate system defined by three points. The first point is the origin of the system; the second gives the direction of the first (x) axis. Together all three points must span a plane which will be the plane of the first (x) and the second (y) axes, having the third (z) axis as normal. 
    AnyVec3 p1=.Corners.PlateCenter.sRel;
    AnyVec3 p2=0.5*(.Corners.c01.sRel+.Corners.c04.sRel);
    AnyVec3 p3=0.5*(.Corners.c01.sRel+.Corners.c02.sRel);
    Axes0 =RotMat(p1,p2,p3);
    
    AnyInt plnr=No;
    AnyFloat Origins= C3D_OBJECT.Groups.FORCE_PLATFORM.ORIGIN.Data;
    AnyVar z_check = iffun(gtfun(Origins[plnr][2], 0), 1, -1);
    AnyMessage Origin_Z_value_message= 
    {
      TriggerConst = iffun(gteqfun(.z_check,0), 1, 0);
      Type = MSG_Message ;
      Message = "The Origin of this force plate is written as positive. So this value will be converted as negative automatically. Please refer to www.c3d.org/HTML/type41.htm ";
    };    
    //Transducer location      
    AnyRefNode TransducerLocation ={
      AnyFloat Origins= C3D_OBJECT.Groups.FORCE_PLATFORM.ORIGIN.Data;
      AnyVar xdist=.z_check*Origins[.plnr][0]*C3D_OBJECT.PointsScaleFactor;//distance from x axis on transducer to x axis of center of plate
      AnyVar ydist=.z_check*Origins[.plnr][1]*C3D_OBJECT.PointsScaleFactor; //distance from y axis on transducer to y axis of center of plate
      AnyVar zdist=.z_check*Origins[.plnr][2]*C3D_OBJECT.PointsScaleFactor;//distance from z axis on transducer to z surface of plate
      sRel={xdist,ydist,zdist};
      AnyDrawRefFrame drw={ScaleXYZ=0.4*{1,1,1};RGB={1,0,0};};
    };
    
    AnyRefNode PlateSurface = {
      sRel = ( 0.25*(
               ..SurfaceCorner_c01 +
               ..SurfaceCorner_c02 +
               ..SurfaceCorner_c03 +
               ..SurfaceCorner_c04 ) - .r0)*.Axes0;
        
        
      AnyRefNode SurfaceGraphics = {
        sRel={0,0,0.03};
        AnyVec3 Size={
          vnorm( ...SurfaceCorner_c01 - ...SurfaceCorner_c02 ,2),
          vnorm( ...SurfaceCorner_c02 - ...SurfaceCorner_c03 ,2),
          0.06
        };

        AnyDrawSurf DrwSurfaceBox = 
        {
          FileName = "box";
          AnyVar LoadRatio = ....InContactOnOff * ....OnOff*vnorm(....Force.Flocal) / (....MaxLoad+ 0.001)  ;
          RGB = 0.45*{1,1,1} ;
          ScaleXYZ= .Size/0.30;
          Opacity =0.20+ ....InContactOnOff *....OnOff*(0.05+ 0.4* LoadRatio);
          Face=-1;
          Visible = On;
        };    
      };
    };

  };  
  
  AnyKinEqSimpleDriver ForcePlateDriver ={
    AnyKinLinear ForcePlateLin={
      AnyRefNode &ref1=..Corners.PlateCenter;
      AnySeg &ref2=..ForcePlate;
      Ref=0;
    };
    
    AnyKinRotational ForcePlateRot={
      AnyRefNode &ref1=..Corners.PlateCenter;
      AnySeg &ref2=..ForcePlate;
      Type=RotAxesAngles;
    };
    DriverPos={0,0,0,0,0,0}; 
    DriverVel={0,0,0,0,0,0};
    Reaction.Type = {Off,Off,Off,Off,Off,Off};
  };
  
  AnyFloatVar tStart = C3D_OBJECT.Header.FirstFrameNo/C3D_OBJECT.Header.VideoFrameRate;
  AnyFloatVar tEnd =  (C3D_OBJECT.Header.LastFrameNo+1)/C3D_OBJECT.Header.VideoFrameRate;
  AnyInt NoAnalogData= (C3D_OBJECT.Header.LastFrameNo - C3D_OBJECT.Header.FirstFrameNo +1)*C3D_OBJECT.Header.NoAnalogSamplesPer3DFrame;
  AnyFloat Time= farr( tStart, (tEnd-tStart)/( NoAnalogData - 1) ,  NoAnalogData);
  
  
  AnyFunInterpol load ={
    Type=PiecewiseLinear;
    T=.Time;
    Data=.Cal'*{Obj2Num(.Fx),Obj2Num(.Fy),Obj2Num(.Fz),Obj2Num(.Mx),Obj2Num(.My),Obj2Num(.Mz)};
  }; 
  
  AnyVar FzTotal=load(ForcePlateDriver.t)[2];
  AnyVar OnOff=iffun(gtfun(-FzTotal,10.0),1.0,0.0);
  AnyVar InContactOnOff = iffun( eqfun(0, ContactDetectionLimb2.NodeWithInBox.WithinBoxAndVelBelowThreshold +
                                          ContactDetectionLimb1.NodeWithInBox.WithinBoxAndVelBelowThreshold)
                                   , 0, 1);

  AnyForce3D Force ={
    
    AnyRefFrame  &ref=.ForcePlate.TransducerLocation ;
    Flocal=.OnOff*{.load(.ForcePlateDriver.t)[0],.load(.ForcePlateDriver.t)[1],.load(.ForcePlateDriver.t)[2]};
    AnyDrawVector DrawForce = 
    {
      AnyRefFrame &ref=.ref;
      Vec=.Flocal*1/1000;
      PointAway = Off;
      DrawCoord = Off;
      
      Line.RGB ={0,0,1};
      Line.Thickness = 0.01;
      Line.End.Thickness = 2*0.01;
      Line.End.Length = 4*0.01;
      GlobalCoord=Off;
    };
  };  
  
  AnyMoment3D Moment = 
  {
    AnyRefFrame  &ref=.ForcePlate.TransducerLocation ;
    Mlocal=.OnOff*{.load(.ForcePlateDriver.t)[3],.load(.ForcePlateDriver.t)[4],.load(.ForcePlateDriver.t)[5]}*C3D_OBJECT.PointsScaleFactor;
    AnyDrawVector DrawMoment = 
    {
      AnyRefFrame &ref=.ref;
      Vec=.Mlocal*1/1000;
      PointAway = Off;
      DrawCoord = Off;
      Line.RGB ={0,1,1};
      Line.Thickness = 0.01;
      Line.End.Thickness = 2*0.01;
      Line.End.Length = 4*0.01;
      GlobalCoord=Off;
    };
  };  
  
  AnyFolder CenterOfPressure =
  {
     AnyForceMomentMeasure2 NetEffectMeasure = 
     {
       AnyRefFrame& ref = ..ForcePlate.PlateSurface;
	   AnySeg& refseg = ..ForcePlate;
       AnyForceBase& Forces = ..Force;
       AnyForceBase& Moments = ..Moment;
        
        AnyVec3 Flocal = F*ref.Axes;
        AnyVec3 Mlocal = M*ref.Axes;
     };
     
     AnyVar fx = NetEffectMeasure.Flocal[0]; 
     AnyVar fy = NetEffectMeasure.Flocal[1]; 
     AnyVar fz = NetEffectMeasure.Flocal[2];
     AnyVar mx = NetEffectMeasure.Mlocal[0]; 
     AnyVar my = NetEffectMeasure.Mlocal[1]; 
     AnyVar mz = NetEffectMeasure.Mlocal[2]; 

     AnyVar fzz =iffun(gtfun(abs(fz),0),fz,fz+1000000);
     
     AnyVar Vx= -my/fzz;
     AnyVar Vy= mx/fzz;
     AnyVar Vz= 0;     
     
     AnyVar OnOff=.OnOff;

     AnyRefFrame& ref_ForcePlate = .ForcePlate;
     ref_ForcePlate  = 
     {
        AnyDrawSphere COP_ball = 
        {
            RGB = {0,1,0};
            ScaleXYZ = 0.015 *{1,1,1};
            //Opacity = iffun(gtfun(..fz, -10.0), 0.0, 1.0);
            Opacity = ..OnOff;
            Position = {..Vx, ..Vy, ..Vz};
        };       
     };
     
     AnyDrawLine Line = 
     {
       p0 = {.Vx, .Vy, .Vz};
       p1 = p0+0.004*.OnOff*{.fx, .fy, .fz};
       Visible = ..Switch_DrawForceVectorFromCOP ;
       AnyRefFrame &ref = ..ForcePlate;
       
       Line.RGB ={0,0,1};
       Line.Thickness = 0.01;
       Line.End.Thickness = 2*0.01;
       Line.End.Length = 4*0.01;
       GlobalCoord=Off;
     };
     
  };  
   
  #if VerticalDirection=="X"
  AnyIntArray Index={1,2,0};
  #endif
  
  #if VerticalDirection=="Y" 
  AnyIntArray Index={0,2,1};
  #endif
  
  #if VerticalDirection=="Z" 
  AnyIntArray Index={0,1,2};
  #endif
  
  #if (VerticalDirection!="X") & (VerticalDirection!="Y") & (VerticalDirection!="Z") 
  AnyIntArray Index = {{1,2,0},{0,2,1},{0,1,2}}[argmax(round(abs(ForcePlate.Axes0'[2])))];
  #endif
  
  
  AnyFolder ContactDetectionLimb1 ={
    AnyVec3 P1= .Limb1.HeelContactNodeLow.r;
    AnyVar P1Vel= vnorm(.Limb1.HeelContactNodeLow.rDot,2);
    
    AnyVec3 P2= .Limb1.ToeLateralContactNode.r;
    AnyVar P2Vel= vnorm(.Limb1.HeelContactNodeLow.rDot,2);
    
    #include "ContactDetectionNew.any"
    
    AnyMuscleModelUsr1 InContactMuscle = {
      F0 = 0;
      S = .NodeWithInBox.WithinBoxAndVelBelowThreshold *10000;
    };
    
    AnyMuscleModelUsr1 NoContactMuscle = {
      AnyVar Limb2Contact=iffun(eqfun(..ContactDetectionLimb2.NodeWithInBox.WithinBoxAndVelBelowThreshold ,1.0),0.0,1.0); //equal 0 if limb2 in contact
      S =Limb2Contact*.NodeWithInBox.OutsideBoxOrVelHigherThanThreshold*10000;
      F0 = 0;
    };
    
    #if FootPresent
    
    AnyFolder PlateFootReactions = {
      AnySeg &ref1=..ForcePlate;
      AnySeg &ref2=..Limb1;
      AnyMuscleModel &MusMdl=.InContactMuscle;
      #include "<ANYBODY_PATH_TOOLBOX>/Mocap/ArtificialMuscleConnection.any"
    };
    #endif
    
    AnyFolder PlateGroundReactions={
      AnyRefFrame &ref1=..Corners.PlateCenter;
      AnySeg &ref2=..ForcePlate;
      AnyMuscleModel &MusMdl=.NoContactMuscle;
      #include "<ANYBODY_PATH_TOOLBOX>/Mocap/ArtificialMuscleConnection.any"
    };
  };
 
  AnyFolder ContactDetectionLimb2 = {
    AnyVec3 P1= .Limb2.HeelContactNodeLow.r;
    AnyVar P1Vel= vnorm(.Limb2.HeelContactNodeLow.rDot,2);
    
    AnyVec3 P2= .Limb2.ToeLateralContactNode.r;
    AnyVar P2Vel= vnorm(.Limb2.HeelContactNodeLow.rDot,2);
    
    #include "ContactDetectionNew.any"
    
    AnyMuscleModelUsr1 InContactMuscle = {
      F0 = 0;
      S = .NodeWithInBox.WithinBoxAndVelBelowThreshold *10000;
    };
    
    AnyMuscleModelUsr1 NoContactMuscle = {
      AnyVar Limb1Contact=iffun(eqfun(..ContactDetectionLimb1.NodeWithInBox.WithinBoxAndVelBelowThreshold ,1.0),0.0,1.0); //equal 0 if limb1 in contact
      S =Limb1Contact*.NodeWithInBox.OutsideBoxOrVelHigherThanThreshold*10000;
      F0 = 0;
    };
    
    #if FootPresent
    
    AnyFolder PlateFootReactions={
      AnySeg &ref1=..ForcePlate;
      AnySeg &ref2=..Limb2;
      AnyMuscleModel &MusMdl=.InContactMuscle;
      #include "<ANYBODY_PATH_TOOLBOX>/Mocap/ArtificialMuscleConnection.any"
    };
    
    #endif
    
    AnyFolder PlateGroundReactions={
      AnyRefFrame &ref1=..Corners.PlateCenter;
      AnySeg &ref2=..ForcePlate;
      AnyMuscleModel &MusMdl=.NoContactMuscle;
      #include "<ANYBODY_PATH_TOOLBOX>/Mocap/ArtificialMuscleConnection.any"
    };
  };
  
#if CREATE_KIN_GRF == 1
  
  ForcePlate =
  {
    AnyRefNode KinGRF_rotnode = { ARel = RotMat(pi,y); };
  };
  
  AnyFolder Kinematic_GRF = 
  {
    
    AnyFloat weightdata = sqrt(Calculations.norm);
    AnyVar max_val = max({ max(weightdata),0.000001});
    AnyVar Th = 0.05*max_val;
    
    // Thresshold the weight data
    AnyVector ThresHolded = iffun(gtfun(weightdata, Th ),
                             (weightdata-Th )/(max_val-Th),
                             0*farr(0.0,1.0,NumElemOf(weightdata)));

    AnyFunInterpol GlobalCopFun = 
    {
      Type = Bspline;
      T = ..Time;
      Data = ((1+0*farr(0.0,1.0,..NoAnalogData))'*{..ForcePlate.r0}+ (..ForcePlate.Axes0*.Calculations.GRF_start.Data)')';
    };    

    
    
    // Alternative Time array which starts from tStart and ends at tEnd  
    AnyInt NoAnalogData2= max({Folder.Header.NoAnalogSamplesPer3DFrame,
                               (Folder.Header.LastFrameNo - Folder.Header.FirstFrameNo)*Folder.Header.NoAnalogSamplesPer3DFrame});
    AnyFloat tStart2 = .tStart+1e-7;
    AnyFloat tEnd2 = max({tStart2+1/Folder.Header.VideoFrameRate,.tEnd-1/Folder.Header.VideoFrameRate})-1e-7;
    AnyFloat Time2 = farr( tStart2, (tEnd2-tStart2)/( max({1,NoAnalogData2 - 1})) ,  NoAnalogData2);

    AnyFloat limb1_COP_dist = vnorm(KIN_GRF_LIMB1_FUN(Time2) - 
                                    GlobalCopFun(Time2));
    AnyFloat limb2_COP_dist = vnorm(KIN_GRF_LIMB2_FUN(Time2)- 
                                    GlobalCopFun(Time2));

    AnyFunInterpol Weight_limb1 = 
    {
       Type = Bspline;
       T = .Time2;
       Data = {iffun(lteqfun(.limb1_COP_dist,.limb2_COP_dist ), .ThresHolded, 0.0*.ThresHolded)};
    };

    AnyFunInterpol Weight_limb2 = 
    {
       Type = Bspline;
       T = .Time2;
       Data = {iffun(lteqfun(.limb2_COP_dist,.limb1_COP_dist ), .ThresHolded, 0.0*.ThresHolded)};
    };


    
    
    AnySeg Frame = 
    {
      Mass = 0.0;
      Jii = {0.0, 0.0, 0.0};
      AnyDrawVector arrow = {Vec ={0,0,..Calculations.GRF_normalized(.t)[0]};GlobalCoord = Off;Line.Thickness = 0.01;};
      AnyDrawRefFrame drw = { ScaleXYZ = 0.2*{1,1,1};};
      AnyRefNode vector= {sRel = {0,0,1};};
    };
    
    AnyKinEq lock_z_rot= {
      AnyKinMeasureOrg zrot = {
        AnyKinRotational rot = {
          Type= RotVector;
          AnyRefFrame &ref0 = ....ForcePlate.KinGRF_rotnode;
          AnyRefFrame &ref1 = ...Frame;
        };
        MeasureOrganizer = {2};
      };
    };
    
    AnyFolder Calculations = {
      
      AnyVector T =  ..load.T;
      AnyVector fx = ..load.Data[0]; 
      AnyVector fy = ..load.Data[1]; 
      AnyVector fz = ..load.Data[2];
      AnyVector mx =  (1/1000)*..load.Data[3]; 
      AnyVector my =  (1/1000)*..load.Data[4]; 
      AnyVector mz =  (1/1000)*..load.Data[5]; 
      
      AnyVector norm = vnorm({fx,fy,fz}');
      
      // Values used when dividing. To avoid deviding by zero. 
      AnyVar force_thresshold = 0.05*max(abs(fz));
      AnyVector _fz = iffun(gtfun(abs(fz),force_thresshold ),fz, fz+10^10);
      AnyVector _norm = iffun(gtfun(abs(norm),force_thresshold ),norm, norm+10^10) ;

      
      AnyVar originz = -1*..ForcePlate.TransducerLocation.zdist;
      
      
      AnyVector Vx= (originz*fx-my)/( _fz ) ;
      AnyVector Vy= (mx+originz*fy)/( _fz );
      AnyVector Vz= 0*Vy;
      
      AnyFunInterpol GRF_normalized = 
      {
        Type = PiecewiseLinear;
        T = .T;
        Data = {.norm/( iffun(gtfun(max(.norm),0),max(.norm), 10^10) )};
      };
      
      AnyFunInterpol GRF_start = 
      { 
        Type = PiecewiseLinear;
        T = .T;
        Data = {.Vx, .Vy, .Vz};
      };    
      AnyFunInterpol GRF_end = 
      { 
        Type = PiecewiseLinear;
        T = .T;
        
        Data = {.Vx + .fx/(._norm),
          .Vy + .fy/(._norm)
          //.COP_cal.Vz + .COP_cal.fz/ (.COP_cal.norm)
        };      
      };
      
      
    };//KinGRF_Calculations 
    
    
    AnyKinDriver COPDriver = {
      AnyKinLinear start_lin = {
        AnyRefFrame &ref0 = ...ForcePlate.PlateSurface;
        AnyRefFrame &ref1 = ..Frame;
        Ref = 0;
      };
      AnyParamFun &fun = .Calculations.GRF_start;
      CType = {Hard,Hard,Hard};
    };
    
    AnyKinDriver DirectionDriver = {
      AnyKinMeasureOrg end_lin_xy = {
        AnyKinLinear lin = 
        {
          AnyRefFrame &ref0 = ....ForcePlate.PlateSurface;
          AnyRefFrame &ref1 = ...Frame.vector;
          Ref = 0;
        };
        MeasureOrganizer = {0,1};
      };
      AnyParamFun &fun = .Calculations.GRF_end ;
      CType = {Hard, Hard};
    };  
  } ;
  #endif
  
};
